= ProjectD

Стандарт для среды разработки (SDE) и его референсная имплементация (project daemon).

__ произносится как "проджект ди" __

https://github.com/projectd-org/projectd[GitHub] +
https://discord.gg/2PbUG6vUTR[Discord]

== Мотивация
*Представь себе что ты хранишь данные, необходимые для работы программы, в обычных файлах.*

У тебя есть бессчётное множество SQL, no-SQL, key-value хранилищ.

Со всеми их гарантиями, взаимосвязями между данными, контролем целостности, версионностью...

Ну ты понял.

А ты по старинке, ручками, пишешь данные в файлы и читаешь их оттуда.

Предусматриваешь контроль за целостностью. +
Проверяешь корректность взаимосвязей. +
Добавляешь свою систему миграций. +
Может даже обрабатываешь эти файлы sed'ом.

Странно, правда? Вряд ли кто-то назовёт это нормальным.

*А теперь скажи, пожалуйста.*

Почему ты делаешь именно это, когда пишешь свой код?

Почему твой код хранится как обычный текст, хотя это структура данных?

Почему конфиги утилит хранятся как текст, хотя это тоже структуры данных?

Почему эти разнородные тексты обрабатывается утилитами как единая куча файлов?

Почему утилиты определяют организацию этой кучи?

Кажется, программисты должны работать с данными и алгоритмами. +
Почему тогда наш код это всё ещё текст и файлы?

== Дано
На данный момент процесс разработки проектов примерно такой:

* Клонируются из гита (скорее всего, из гитхаба)
* Разрабатывается на 99% в IDE в 3 основных системах:
windows, macos, linux, всё 64 bit
* Во время разработки запускается куча тулов для обработки и генерации кода:
получение зависимостей, компилятор, линтер, кодген, файловый сервер и т.д.
* Проект как-то запускается локально
* Изменения фиксируются в том же гите
* Потом запускается CI

Все эти шаги осуществляются с помощью каких-то утилит (обычно из командной строки или напрямую из IDE).

Rule-of-thumb для определения этих утилит - у них есть какой-то конфиг в корне проекта.

package.json (и иже с ними в других языках), .git, .idea, *ignore файлы, you name it.

Все они обрабатывают код согласно своим правилам.

Что именно обрабатывать и как - определяется конфигами, в том числе их расположением в файловой иерархии.

== Проблемы

. Код обрабатывается как текст - хотя это по сути AST
.. Возможность зафиксировать некорректный синтаксис
.. Появляются общие кодстайлы, хотя они могут быть индивидуальными
.. Околонулевое переиспользование промежуточных представлений кода - все сами всё парсят и т.д.

. Код обрабатывается как куча файлов
.. Возможность зафиксировать некорректную структуру (битые импорты/неправильные зависимости)
.. Общая файловая структура проекта для всех юзкейсов - дерево (связный ациклический граф, симлинки не используют)

. Вышесказанное сильно усложняют разработку своего тула - надо интегрироваться в существующие
(плагинами, а API у всех разный) или снова писать код (использование готовых библиотек - это тоже код)
для получения конфигов, поиска файлов, файл-вотчера, парсинга, принтинга и т.д.

. Сильно усложняется рефакторинг (за пределами поддерживаемого IDE/LSP) - приходится писать регэкспы или...
Писать свою программу со всеми прелестями предыдущего пункта.
Почему я не могу сказать "IDE, замени все токены на которые ругается компилятор вот на такие"?
Потому что код - это текст. И ошибки - тоже текст. И они не связаны (формально). И всё это в файлах.

. Тулы обычно рассчитаны на однократный запуск, а не на watch режим
.. Поэтому кодген, например приходится запускать руками после каждого изменения файлов.
Тут может помочь IDE, но зафиксировать эту обработку можно только если вся команда пользуется одной IDE.
... Сгенерированные файлы сильно засоряют гит и саму структуру файлов, хотя они не нужны пока кодген детерминирован
.. Это, вместе с невозможностью переиспользовать промежуточные представления, сильно снижает производительность
... Цикл разработки сильно растягивается

. Конфиги лежат вперемешку с кодом
.. Поэтому обычно во всех ignore файлах есть остальные ignore файлы
.. Сильно засоряют визуальную структуру и поиск

. Обрабатываемые файлы определяются в конфиге - хотя это должны быть независимые параметры
.. Тулы частенько предполагают структуру файлов и не всегда позволяют её конфигурировать
.. Расположение конфига может влиять на файлы, которые обрабатываются утилитой - неявное поведение
.. Множественные конфиги и наследование конфигов поддерживается не всеми утилитами

. При этом у каждого тула свой формат конфигов и обычно нигде не зафиксирована ожидаемая схема данных
.. Нет, описание схемы конфига в документации не считается фиксацией пока оно не тестируется
и пока конфиг нельзя проверить без запуска самой утилиты
.. Формат конфигов вообще не должен диктоваться автором тула, его должна интересовать только схема данных

== Решение
Разработать:

. Стандарт среды разработки, который включает:
.. Формат хранения кода и конфигов утилит как взаимосвязанных типизированных структур данных
.. Протокол общения между утилитами, основанный на этих структурах
. Путь бесшовной миграции для проектов и утилит
. Референсную имплементацию в виде демона

//отделение кода и конфигов, утилиты как чистые функции

//== State of the art
//llvm, cargo, js-бандлеры: Rome.tools, parcel, webpack, etc...
//
//cosmiconfic
//
//c8s, terraform

//абстракции фс, преимущества
//симлинки и атрибуты не используются из-за разного поведения на разных системах
//
//обратная совместимость
//
//неправильная семантика - код не дерево файлов, а набор взаимосвязанных структур данных и правил их обработки
//
//запуск тулов напрямую из бинарника проекта
//
//ninja, mobx, graphql, swagger, smalltalk, redox
//linux way - он про файлы
